<!doctype html>
<html>
  <head>
    <style>
      canvas {
        image-rendering: pixelated;
    background: #cdcdcd;        
    width:200px;
        height: 200px;
      }
  	</style>
  </head>

  <body>
    <canvas id="canvas"></canvas>
    <canvas id="canvas2"></canvas>
    <canvas id="canvas3"></canvas>
    <canvas id="canvas4"></canvas>
        <canvas id="canvas6"></canvas>

        <canvas id="canvas7"></canvas>
        <canvas id="canvas8"></canvas>

    <script>
      "use strict";



      function read(ctx) {
        const pixel = new Uint8Array(4);
        ctx.readPixels(0, 0, 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, pixel);
        log(pixel);
      }

      function log(...args) {
        const elem = document.createElement("pre");
        elem.textContent = [...args].join(' ');
        document.body.appendChild(elem);
      }




//UN


{

      let vertex=`
      attribute vec2 vertexPosition;
      void main() {
        gl_Position = vec4(0.0,0.0,0.0,1.0);
        gl_PointSize=1.0;
      }`;

      let fragment=`
      precision mediump float;

      void main() {
        //gl_FragColor = vec4(111,222,333,444);
        gl_FragColor=vec4(0.7,0.2,0.6,1.0);
    
      }`;

      var canvas = document.querySelector("#canvas");
      canvas.width=1;
      canvas.height=1;
      var gl = canvas.getContext("webgl",{premultipliedAlpha:false});

      gl.getExtension("OES_texture_float");
      gl.getExtension("WEBGL_color_buffer_float");

      let program = gl.createProgram();
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertex);
      gl.shaderSource(fragmentShader, fragment);
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      gl.useProgram(program);

      gl.viewport(0,0,1,1);


      let texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.FLOAT, 
        new Float32Array(
            [0.7,0.3,0.8,0.5]
          )
        );
   
      const fb = gl.createFramebuffer();
     // gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

   


gl.enable(gl.BLEND);
gl.blendFunc(gl.DST_COLOR, gl.ZERO);

/*
blendFunc(sfactor, dfactor)

sourceColor=      (0.7, 0.2, 0.6, 1.0)
destinationColor= (0.0, 1.0, 0.0, 1.0)

The formula for the blending color can be described like this: 
color(RGBA) = (sourceColor * sfactor) + (destinationColor * dfactor). 
The RGBA values are between 0 and 1. 

destinationColor  = clearColor = (0.0, 1.0, 0.0, 1.0  )
sourceColor = fragColor        = (0.7, 0.2, 0.6, 1.0)
sfactor = DST_COLOR = (0.0, 1.0, 0.0, 1.0  )
dfactor = ZERO = (0.0, 0.0, 0.0, 0.0  )

color(RGBA) = (0.7, 0.2, 0.6, 1.0) * (0.0, 1.0, 0.0, 1.0  )   + (0.0, 1.0, 0.0, 1.0  ) * (0.0, 0.0, 0.0, 0.0  )
            = (0.0, 0.2, 0.0, 1.0)




*/
    //  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

gl.clearColor(0,1,0,1);
gl.clear(gl.COLOR_BUFFER_BIT);
   gl.drawArrays(gl.POINTS, 0, 1);


console.log('UN');
if (true) {
  let pixels= new Uint8Array(1*1*4);
  gl.readPixels(0,0,1,1,gl.RGBA,gl.UNSIGNED_BYTE,pixels);
  console.log(pixels);
} else
{
  let pixels= new Float32Array(1*1*4);
  gl.readPixels(0,0,1,1,gl.RGBA,gl.FLOAT,pixels);
  console.log(pixels);
}
 


    }







//DEUX






{

      let vertex=`
      attribute vec2 vertexPosition;
      void main() {
        gl_Position = vec4(0.0,0.0,0.0,1.0);
        gl_PointSize=1.0;
      }`;

      let fragment=`
      precision mediump float;

      void main() {
        //gl_FragColor = vec4(111,222,333,444);
        gl_FragColor=vec4(0.7,0.2,0.6,1.0);
    
      }`;

      var canvas = document.querySelector("#canvas6");
      canvas.width=1;
      canvas.height=1;
      var gl = canvas.getContext("webgl",{premultipliedAlpha:false});

      gl.getExtension("OES_texture_float");
      gl.getExtension("WEBGL_color_buffer_float");

      let program = gl.createProgram();
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertex);
      gl.shaderSource(fragmentShader, fragment);
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      gl.useProgram(program);

      gl.viewport(0,0,1,1);


      let texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
   
      const fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);


   


gl.enable(gl.BLEND);
gl.blendFunc(gl.DST_COLOR, gl.ZERO);



gl.clearColor(0,1,0,1);
gl.clear(gl.COLOR_BUFFER_BIT);
   gl.drawArrays(gl.POINTS, 0, 1);

console.log("DEUX");
if (true) {
  let pixels= new Uint8Array(1*1*4);
  gl.readPixels(0,0,1,1,gl.RGBA,gl.UNSIGNED_BYTE,pixels);
  console.log(pixels);
} else
{
  let pixels= new Float32Array(1*1*4);
  gl.readPixels(0,0,1,1,gl.RGBA,gl.FLOAT,pixels);
  console.log(pixels);
}
 


    }






//TROIS

{

      let vertex=`
      attribute vec2 vertexPosition;
      void main() {
        gl_Position = vec4(0.0,0.0,0.0,1.0);
        gl_PointSize=1.0;
      }`;

      let fragment=`
      precision mediump float;

      void main() {
        gl_FragColor = vec4(111,222,333,444);
    
      }`;

      var canvas = document.querySelector("#canvas7");
      canvas.width=1;
      canvas.height=1;
      var gl = canvas.getContext("webgl",{premultipliedAlpha:false});

      gl.getExtension("OES_texture_float");
      gl.getExtension("WEBGL_color_buffer_float");

      let program = gl.createProgram();
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertex);
      gl.shaderSource(fragmentShader, fragment);
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      gl.useProgram(program);

      gl.viewport(0,0,1,1);


      let texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
   
      const fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);


   


gl.enable(gl.BLEND);
gl.blendFunc(gl.DST_COLOR, gl.DST_COLOR);
/*
blendFunc(sfactor, dfactor)

sourceColor=   fragColor =  (111,222,333,444)
destinationColor= clearColor  = (0.0, 10.0, 0.0, 10.0)

The formula for the blending color can be described like this: 
color(RGBA) = (sourceColor * sfactor) + (destinationColor * dfactor). 
The RGBA values are between 0 and 1. 

sfactor = DST_COLOR = (0.0, 10.0, 0.0, 10.0  )
dfactor = DST_COLOR = (0  , 10,   0 , 10    )

color(RGBA) = (111,222,333,444) * (0.0, 10.0, 0.0, 10.0  )   + (0.0, 10.0, 0.0, 10.0  ) * (0.0, 10.0, 0.0, 10.0  ) 
            = (0 , 2220 , 0 , 4440 ) + ( 0, 100 , 0 , 100 )
            = ( 0 , 2320 , 0 , 4540)




*/


gl.clearColor(0,10,0,10);
gl.clear(gl.COLOR_BUFFER_BIT);
   gl.drawArrays(gl.POINTS, 0, 1);

console.log("TROIS");
if (false) {
  let pixels= new Uint8Array(1*1*4);
  gl.readPixels(0,0,1,1,gl.RGBA,gl.UNSIGNED_BYTE,pixels);
  console.log(pixels);
} else
{
  let pixels= new Float32Array(1*1*4);
  gl.readPixels(0,0,1,1,gl.RGBA,gl.FLOAT,pixels);
  console.log(pixels);
}
 


    }








//QUATRE

{

      let vertex=`
      attribute vec2 vertexPosition;
      void main() {
        gl_Position = vec4(0.0,0.0,0.0,1.0);
        gl_PointSize=1.0;
      }`;

      let fragment=`
      precision mediump float;

      void main() {
        gl_FragColor = vec4(111,222,333,444);
    
      }`;

      var canvas = document.querySelector("#canvas8");
      canvas.width=1;
      canvas.height=1;
      var gl = canvas.getContext("webgl",{premultipliedAlpha:false});

      gl.getExtension("OES_texture_float");
      gl.getExtension("WEBGL_color_buffer_float");

      let program = gl.createProgram();
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertex);
      gl.shaderSource(fragmentShader, fragment);
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      gl.useProgram(program);

      gl.viewport(0,0,1,1);


      let texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
   
      const fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);


   


gl.enable(gl.BLEND);
gl.blendFunc(gl.DST_COLOR, gl.SRC_COLOR);
/*
blendFunc(sfactor, dfactor)

sourceColor=   fragColor =  (111,222,333,444)
destinationColor= clearColor  = (0.0, 10.0, 0.0, 10.0)

The formula for the blending color can be described like this: 
color(RGBA) = (sourceColor * sfactor) + (destinationColor * dfactor). 
The RGBA values are between 0 and 1. 

sfactor = DST_COLOR = (0.0, 10.0, 0.0, 10.0  )
dfactor = SRC_COLOR = (111,222,333,444)

color(RGBA) = (111,222,333,444) * (0.0, 10.0, 0.0, 10.0  )   + (0.0, 10.0, 0.0, 10.0  ) * (111,222,333,444)
            = (0 , 2220 , 0 , 4440 ) + (0 , 2220 , 0 , 4440 ) 
            = ( 0 , 4440 , 0 , 8880)




*/


gl.clearColor(0,10,0,10);
gl.clear(gl.COLOR_BUFFER_BIT);
   gl.drawArrays(gl.POINTS, 0, 1);

console.log("QUATRE");
if (false) {
  let pixels= new Uint8Array(1*1*4);
  gl.readPixels(0,0,1,1,gl.RGBA,gl.UNSIGNED_BYTE,pixels);
  console.log(pixels);
} else
{
  let pixels= new Float32Array(1*1*4);
  gl.readPixels(0,0,1,1,gl.RGBA,gl.FLOAT,pixels);
  console.log(pixels);
}
 


    }








    {



      let vertex=`
      attribute vec2 vertexPosition;
      void main() {
        gl_Position = vec4(
          0.0,
          0.0,
          0.0,
          1);
      }`;

      let fragment=`
      precision mediump float;

      void main() {
        //gl_FragColor = vec4(111,222,333,444);
        gl_FragColor = vec4(
          0.7,
          0,
          0.5,
          0.5
        );
      }`;

      var canvas = document.querySelector("#canvas2");
      canvas.width=1;
      canvas.height=1;
      var gl = canvas.getContext("webgl",
        {
          premultipliedAlpha:false
        }

      );

      gl.getExtension("OES_texture_float");
      gl.getExtension("WEBGL_color_buffer_float");

      let program = gl.createProgram();
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertex);
      gl.shaderSource(fragmentShader, fragment);
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      gl.useProgram(program);




      let texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, 
        new Uint8Array(
            [0.7*255,0.3*255,0.8*255,0.5*255]
          )
        );
     const fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);


      gl.viewport(0, 0, 1, 1);
    

     // gl.drawArrays(gl.POINTS, 0, 1);

//gl.clearColor(0,0,0,10.5);
//gl.clear(gl.COLOR_BUFFER_BIT);

      let pixels= new Uint8Array(1*1*4);

      gl.readPixels(0,0,1,1,gl.RGBA,gl.UNSIGNED_BYTE,pixels);
      console.log(pixels);
      //            [0.7,0.3,0.8,0.5]








    }





//3e version


    {



      let vertex=`
      attribute vec2 vertexPosition;
      void main() {
        gl_Position = vec4(
          0.0,
          0.0,
          0.0,
          1);
      }`;

      let fragment=`
      precision mediump float;

      void main() {
        //gl_FragColor = vec4(111,222,333,444);
        gl_FragColor = vec4(
          0.7,
          0,
          0.5,
          0.5
        );
      }`;

      var canvas = document.querySelector("#canvas3");
      canvas.width=1;
      canvas.height=1;
      var gl = canvas.getContext("webgl",
        {
          premultipliedAlpha:true
        }

      );

      gl.getExtension("OES_texture_float");
      gl.getExtension("WEBGL_color_buffer_float");

      let program = gl.createProgram();
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertex);
      gl.shaderSource(fragmentShader, fragment);
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      gl.useProgram(program);




      let texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, 
        new Uint8Array(
            [0.7*255,0.3*255,0.8*255,0.5*255]
          )
        );
     const fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);


      gl.viewport(0, 0, 1, 1);
    

     // gl.drawArrays(gl.POINTS, 0, 1);

//gl.clearColor(0,0,0,10.5);
//gl.clear(gl.COLOR_BUFFER_BIT);

      let pixels= new Uint8Array(1*1*4);

      gl.readPixels(0,0,1,1,gl.RGBA,gl.UNSIGNED_BYTE,pixels);
      console.log(pixels);
      //            [0.7,0.3,0.8,0.5]








    }



//4e version


    {



      let vertex=`
      attribute vec2 vertexPosition;
      void main() {
        gl_Position = vec4(
          0.0,
          0.0,
          0.0,
          1);
      }`;

      let fragment=`
      precision mediump float;

      void main() {
        gl_FragColor = vec4(
          0.7,
          0,
          0.5,
          0.5
        );
        gl_FragColor.rgb *= gl_FragColor.a;
      }`;

      var canvas = document.querySelector("#canvas4");
      canvas.width=1;
      canvas.height=1;
      canvas.style.width="50px";
      canvas.style.height="50px";

      var gl = canvas.getContext("webgl",
        {
          premultipliedAlpha:true
        }

      );

  

      let program = gl.createProgram();
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertex);
      gl.shaderSource(fragmentShader, fragment);
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      gl.useProgram(program);




      gl.bindFramebuffer(gl.FRAMEBUFFER, null);



      gl.viewport(0, 0, 1, 1);

     // gl.enable(gl.BLEND);
     // gl.blendFunc(gl.ONE,gl.ONE_MINUS_SRC_ALPHA);
      // 111, ....


      gl.enable(gl.BLEND);
     gl.blendFunc(gl.ONE,gl.ONE_MINUS_SRC_ALPHA);
     //ici il y a juste une composition de la couleur d'un point tracé en WebgL
     // et de la couleur du canvas. 
     //capture ecran = 0.43 , ...

      // 
      

gl.clearColor(1,1,1,1);
gl.clear(gl.COLOR_BUFFER_BIT);
    

     gl.drawArrays(gl.POINTS, 0, 1);

read(gl);
/*
co= Cs*as + Cb*ab(1-as)
ao = as + ab*(1-as)
Cs= 0.7, 0 , 0.5  as=0.5
Cb= 1 1 1         ab =1

co= (0.7*0.5 , ... ) + (1,..)*1*(1-0.5)
    =  (0.35, ... ) + (0.5 , ... )
    =  (0.85  , ...  )
ao = 0.5 + 1 * ( 1-0.5) = 0.5 + 1 - 0.5 = 1

capture ecran = (216/255 , ...)  = (0.847 , ...)


*/






    }






//5e version , dans une texture


    {



      let vertex=`
      attribute vec2 vertexPosition;
      void main() {
        gl_Position = vec4(
          0.0,
          0.0,
          0.0,
          1);
      }`;

      let fragment=`
      precision mediump float;

      void main() {
        gl_FragColor = vec4(
          0.7,
          0,
          0.5,
          0.5
        );
        gl_FragColor.rgb *= gl_FragColor.a;
      }`;

      var canvas = document.querySelector("#canvas");
      canvas.width=1;
      canvas.height=1;
     

      var gl = canvas.getContext("webgl",
        {
          premultipliedAlpha:true
        }

      );

  

      let program = gl.createProgram();
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertex);
      gl.shaderSource(fragmentShader, fragment);
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      gl.useProgram(program);



      let texture = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, 
        new Uint8Array(
            [0,0,0,0]
          )
        );
     const fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);




      gl.viewport(0, 0, 1, 1);

      gl.enable(gl.BLEND);
   gl.blendFunc(gl.ONE,gl.ONE_MINUS_SRC_ALPHA);

     /*
     

     co= Cs*as + Cb*ab(1-as)
ao = as + ab*(1-as)
Cs= 0.7, 0 , 0.5  as=0.5
Cb= 0 0 0         ab =0

co= (0.7*0.5 , ... ) + (0,0,0)
    =  (0.35, ... ) + (0.5 , ... )
    =  (0.85  , ...  )
ao = 0.5 + 0 * ( 1-0.5) = 0.5 

readpixels     */


  
      


    

    gl.drawArrays(gl.POINTS, 0, 1);

read(gl);







    }


    </script>





  </body>
</html>
