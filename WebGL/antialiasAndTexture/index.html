<!doctype html>

<html>
<style>
  body {background-color: rgb(0,0,0)}
</style>
<body>


  <h1 style="color:white">superposition de 2 éléments &lt;img&gt; contenant particle.png </h1>
  <image src="particle.png">
    <image src="particle.png" style="position:relative;left:-128px">

  <br>


  <h1 style="color:white">...la même chose en WebGL</h1>
  <canvas id="glcanvas"></canvas>
  <br>


  <h1 style="color:white">buffer 1</h1>
  <div id="buffers1"></div>
  <br>

  <h1 style="color:white">buffer 2</h1>
  <div id="buffers2"></div>
  <br>



  <script>



    let vertex=`

        attribute vec2 position;

        void main() {
          gl_Position = vec4(position,0, 1); 
          gl_PointSize = 256.0;


        }
`;
let fragment=`

        precision highp float;
        uniform sampler2D particle;
        void main() {

            vec4 color= texture2D(particle, gl_PointCoord);
            gl_FragColor = vec4( color.rgb * color.a , color.a);


        }
`;
    
  



/*
    let image=new Image();
    image.src="particle.png";

    image.onload = go;
*/

let images=[];

function loadImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.crossOrigin = 'anonymous';
    img.src = url;
  });
}

async function loadImages(imgs) {
  images = await Promise.all(imgs.map(loadImage));
}

async function main() {
  await loadImages([
       'particle.png'
  ]);
  go();
}
main();












    function go() {


      const canvas = document.getElementById("glcanvas");
      canvas.width=512;
      canvas.height=256;
      //canvas.style.backgroundColor="black";
      const gl = canvas.getContext(
            "webgl",
            {
                //depth: false,
                //alpha: false,
                //stencil: false,
                //premultipliedAlpha: false,
            }
          );

      let program = gl.createProgram();
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(vertexShader, vertex);
      gl.shaderSource(fragmentShader, fragment);
      gl.compileShader(vertexShader);
      gl.compileShader(fragmentShader);
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      gl.useProgram(program);

      let aPosition = gl.getAttribLocation(program,"position");
      gl.enableVertexAttribArray(aPosition);
      /*
      global state:
        vertex_array_binding: null (defaut VAO)
           vertex_array[*defaut*]
             attributes:
               enabled | size | type | normalize | stride | offset | divisor | buffer
               ======================================================================
               true    | 4    | FLOAT| false     |    0   |      0 |       0 | null
 

      */

      let particleLoc = gl.getUniformLocation(program,"particle");

      let buffer= gl.createBuffer();
      /*
      buffer[buffer]
      =============
      data:

      */
      gl.bindBuffer(gl.ARRAY_BUFFER,buffer);
      /*
      comon_state
      --------------------------------
      | ARRAY_BUFFER_BINDING | buffer| ========> buffer[buffer]
      ---------------------------------          ==============
      |                      |       |           data:
      ---------------------------------

      */
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(
          [
            -0.5, 0.0,
            +0.0, 0.0
          ]
        ),
        gl.STATIC_DRAW
      );
      /*
          
      comon_state
      --------------------------------
      | ARRAY_BUFFER_BINDING | buffer| ========> buffer[buffer]
      ---------------------------------          ==============
      |                      |       |           data: -0.5 , 0.0,, 0.0 , 0.0
      ---------------------------------

      
      */

      gl.vertexAttribPointer(aPosition,2,gl.FLOAT,false ,0,0);
      /*
      global state:
        vertex_array_binding: null (defaut VAO)
           vertex_array[*defaut*]
             attributes:
               enabled | size | type | normalize | stride | offset | divisor | buffer
               ======================================================================
               true    | 2    | FLOAT| false     |    0   |      0 |       0 | buffer (le buffer 'bindé', actuellement lié, currently bound)
               ----------------------------------------------------------------------
               ....
               .....
 

      */

//Textures provide random access data to shaders. Most often they contain image data but not always.

      let imageTexture = gl.createTexture();
      /*
        texture[imageTexture]
        =====================
        mips:
        texture state:
      */
      //and bound to a texture unit bind point (target) with
      let texUnitIndex= 3;
      gl.activeTexture(gl.TEXTURE0 + texUnitIndex);
      const bindPoint = gl.TEXTURE_2D;
      gl.bindTexture(bindPoint, imageTexture);
//All texture functions reference textures through the bind points on the active texture unit. ie.
//texture = texture_units[activeTexture][bindPoint
/*
global state:
  vertex_array_binding:...
   vertex_array[*defaut*]
   ....

   texture_units:
     TEXTURE_2D     | TEXTURE_CUBE_MAP
     ===============================
  0:   null         | null
  1:   null         | null
  2:   null         | null
  3:   imageTexture | null
  4:   null         | null
  5:   null         | null
  6:   null         | null
  7:   null         | null

*/

      gl.uniform1i(particleLoc, texUnitIndex);


      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[0]);
      //gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    //the texture affected is the current active texture on the specified bind point
      //webglState.textureUnits[activeTexture][bindPoint]

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

      gl.enable(gl.BLEND);
    //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    gl.drawArrays(gl.POINTS, 0, 2);



/*

        let  buffers1= document.getElementById("buffers1");
        buffers1.style.width="400px";
        buffers1.style.height="400px";
        buffers1.style.backgroundColor="black";

       duplicateCanvas("buffers1");

      //   gl.drawArrays(gl.POINTS, 0, 2);

        let  buffers2= document.getElementById("buffers2");
        buffers2.style.width="400px";
        buffers2.style.height="400px";
        buffers2.style.backgroundColor="black";
         duplicateCanvas("buffers2");

*/
    }


    function duplicateCanvas(e) {
      let image = new Image();
      image.onload = function() {
        let div  = document.getElementById(e);
        div.appendChild(image);
      }
      image.src = glcanvas.toDataURL('image/png');
    }



  </script>
</body>

</html>
