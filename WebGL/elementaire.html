<!doctype html>
<html>
  <h1>Les Buffers et WebGL</h1>
  <p>
    Cette page montre les valeurs d'un buffer WebGL.<br>
    Entrons dans le détail :
    Le code javascript & WebGL suivant se termine par l'affichage d'un carré dont les couleurs sont les valeurs d'un buffer.
    Le carré a une taille affichée de 3x3 pixels.<br>
    le voici : <canvas id="canvas"></canvas>
    <br>
    Une capture écran (fouche FN + Impécr) puis une aggrandissement sous Gimp (avec affichage d'une grille) donne l'image suivante
      <img src="image1.png">
    <br>
</p>
<p>

</p>

  <body>
    <script>
      const canvas = document.querySelector('canvas');
      const gl = canvas.getContext('webgl');
      
      gl.getExtension("OES_texture_float");
      gl.getExtension("OES_texture_float_linear");
      
      canvas.style.imageRendering="pixelated";
      canvas.style.backgroundColor="rgb(0,255,0)"
      
      
//https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
      // la taille du carré affiché sera de 3x3 pixels
      let size = 3;
      canvas.style.width = `${size}px`;
      canvas.style.height = `${size}px`;
      
      //on tient compte de la densité de pixels supplémentaire. 
      // mon écran est un 2880x1800 pixels
      let scale = window.devicePixelRatio;
      // scale vaut 2 sur mon ordinateur
      canvas.width = Math.floor(size * scale) ;
      canvas.height = Math.floor(size * scale) ;
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      let vs=`
        attribute vec2 aPosition;
        varying vec2 vPosition;

        void main() {
          gl_Position = vec4(
            (aPosition.x + 0.5)/ ${canvas.width}.0 * 2.0 -1.0,
            (aPosition.y + 0.5)/ ${canvas.height}.0 * 2.0 -1.0,
            0,1);
            
          gl_Position=vec4(aPosition,0,1);
          vPosition = aPosition;
          gl_PointSize = 1.0;
        }`;


      let fs=`
        precision mediump float;

        varying vec2 vPosition;
        void main() {
          gl_FragColor = vec4(1,vPosition.x,vPosition.y,1);  
        }`;

      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader,vs);
      gl.compileShader(vertexShader);
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader,fs);
      gl.compileShader(fragmentShader);
      const program = gl.createProgram();
      gl.attachShader(program,vertexShader);
      gl.attachShader(program,fragmentShader);
      gl.linkProgram(program);

      gl.useProgram(program);

      let positionAttributeLocation = gl.getAttribLocation(program, "aPosition");
      
      let positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
          new Uint8Array([
          0,0,
          0,1,
          0,2,
          0,5,]),
        gl.STATIC_DRAW
      );
      
      let width=60;
      let height=60;
      let x=0;
      let y=0;
      let x1 = 0;
      let x2 = x + width;
      let y1 = y;
      let y2 = y + height;
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        x1, y1,
        x2, y1,
        x1, y2,
        x1, y2,
        x2, y1,
        x2, y2,
      ]), gl.STATIC_DRAW);
      
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
        1, -1,
       -1, 1,
       -1, 1,
       1, -1,
       1, 1,
     ]), gl.STATIC_DRAW);
      
      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(positionAttributeLocation, 2, gl.UNSIGNED_BYTE, false, 0, 0);
      gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER,null);
      
      let textureEcran = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, textureEcran);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,             
        gl.RGBA,
        canvas.width,
        canvas.height,
        0,
        gl.RGBA,
        gl.FLOAT,
        null);
      
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      
      let fbEcran = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER,fbEcran);
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.TEXTURE_2D,
        textureEcran,
        0
      );
      
      gl.bindFramebuffer(gl.FRAMEBUFFER,null);

      gl.drawArrays(gl.TRIANGLES, 0, 6);
      let pixels = new Float32Array(canvas.width*canvas.height*4);
      gl.readPixels(0,0,canvas.width,canvas.height,gl.RGBA,gl.FLOAT,pixels);
      let i=0;
      console.log(pixels.slice(i,i+4));
      i=i+4;


    </script>
  </body>
</html>



