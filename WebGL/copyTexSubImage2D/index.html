<!doctype html>
<html>

  <head>
  	<style>
  		#c {
  			display: none;
  		}
  		canvas , #un , #deux , #trois  , #quatre, #cinq, img { 
  			image-rendering: pixelated;
  			width:70px;
  			height: 70px;





  		 }



.grid {
	width: 70px;
	height: 70px;
	  			  		  			   background-image:
      repeating-linear-gradient(#ccc 0 1px, transparent 1px 100%),
      repeating-linear-gradient(90deg, #ccc 0 1px, transparent 1px 100%);
    background-size: 10px 10px;
    position:relative;
    top:-70px;   
}
  	</style>
  </head>

  <body>
<p>texture initiale</p>
  	<div id="zero"></div>

<canvas id="c"></canvas>



<p> gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,    2,   2,    3, 3,    3, 3);</p>
  	 <div id="un"></div>

<div class="grid"></div>


  <p>gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,    0, 0,    0, 0,    5, 5);</p>
    <div id="deux"></div><div class="grid"></div>


  <p>  gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,    0,   0,    2, 3,    7, 7);</p><div id="trois"></div>
  <div class="grid"></div>




  <p>gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,    1,   2,    0, 0,    5, 5)</p><div id="quatre"></div>
  <div class="grid"></div>



  <p>gl.copyTexImage2D(gl.TEXTURE_2D, 0,   0, 0,    5, 5)</p><div id="cinq"></div>
  <div class="grid"></div>
/*

This function behaves as if texImage2D were called with null data, followed by copyTexSubImage2D. As in copyTexSubImage2D, for any source pixels lying outside the framebuffer, the corresponding destination texels are left untouched, and so they retain their zero-initialized contents as if texImage2D was called with null data. This has the combined effect that, for source pixels lying outside the framebuffer, corresponding destination pixels will have all channels of the associated texels initialized to 0; 
*/


  	<script src="code.js"></script>


  </body>
</html>
