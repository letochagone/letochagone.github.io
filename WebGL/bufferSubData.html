<!doctype html>
<html>
<head>
	<style>
		canvas {
  			border: 1px solid black;
  			image-rendering: pixelated;
  		}

  		.pseudoCode {
  			white-space: pre;
  			background-color: gray;
  		}
  	</style>

  	<link
  	  rel="stylesheet"
      href="highlight/styles/a11y-dark.min.css">

</head>





<body>
	<!--
		le lien suivant donne de bonnes explications pour
		l'utilisation de highlight.js
		https://www.youtube.com/watch?v=ZX1NCf7U3ec
	-->
	<pre><code class="language-javascript">
const canvas = document.querySelector('canvas');
</code></pre>


<p>On donne la taille d'affichage du canvas</p>
<pre><code class="language-javascript">
canvas.style.width="500px";
canvas.style.height="200px";
</code></pre>


<p>On donne la taille du drawingBuffer. Combien de pixels le canvas va contenir.</p>
<pre><code class="language-javascript">
// taille du drawingBuffer
//https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html

canvas.width=5;
canvas.height=2;

const gl = canvas.getContext('webgl');

</code></pre>


<p>When you first create the WebGL context WebGL will set the viewport to match the size of the canvas
Donc la ligne suivante n'est pas nécessaire ici.</p>
<pre><code>
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
</code></pre>


<pre><code class="language-glsl">
const vertex = `
attribute vec2 a_position;
void main() {
  gl_Position = vec4(a_position, 0, 1);
  gl_PointSize = 1.0;
}`;

const fragment = `
precision mediump float;
void main() {
gl_FragColor = vec4(1, 0, 0, 1);
}`;
</code></pre>


<pre><code class="language-javascript"> 
let prg = gl.createProgram();
const vertexShader = gl.createShader(gl.VERTEX_SHADER);
const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(vertexShader, vertex);
gl.shaderSource(fragmentShader, fragment);
gl.compileShader(vertexShader);
gl.compileShader(fragmentShader);
gl.attachShader(prg, vertexShader);
gl.attachShader(prg, fragmentShader);
gl.linkProgram(prg);

gl.useProgram(prg);

const positionAttributeLocation = gl.getAttribLocation(prg, 'a_position');

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
</code></pre>



<p class="pseudoCode">
pseudoCode :
gl = {
  arrayBuffer: positionBuffer;
}
buffer = {
  positionBuffer: null;
}

</p>




<pre><code class="language-javascript">

const positions = new Float32Array(6);

positions[0]=-1+7/5;
positions[1]=-1+1/2;

positions[2]=-1+1/5;
positions[3]=-1+3/2;

positions[4]=-1+9/5;
positions[5]=-1+3/2;


gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

</code></pre>

<p class="pseudoCode">
pseudoCode :
gl = {
  arrayBuffer: positionBuffer;
}
buffer = {
  positionBuffer: [
    positions[0] positions[1]
    positions[2] positions[3]
    positions[4] positions[5]
  ];
}

</p>
<pre><code>

const subPositions = new Float32Array(2);
subPositions[0]= -1 + 3/5;
subPositions[1]= -1 + 1/2;
        // subPositions est un Float32array de 2 éléments
        // chaque élément occupe 4 octets 
        // donc subPositions occupe 8 octets

gl.bufferSubData(gl.ARRAY_BUFFER, 8, subPositions);

</code></pre>
<p class="pseudoCode">

bufferSubData modifie une partie du buffer courant :

pseudoCode :
gl = {
  arrayBuffer: positionBuffer;
}
buffer = {
  positionBuffer: [
       positions[0]    positions[1]
    subPositions[0] subPositions[1]
       positions[4]    positions[5]
  ];
}
bufferData courant :

positions[0]    4 octets (1 élement Float32Array)
positions[1]    4 octets (1 élement Float32Array)

positions[2]    4 octets (1 élement Float32Array)
positions[3]    4 octets (1 élement Float32Array)

positions[4]    4 octets (1 élement Float32Array)
positions[5]    4 octets (1 élement Float32Array)

bufferData modifié :

octet 0 : positions[0]    
octet 4 : positions[1]   

octet 8:  SubPositions[0]   
octet 12: SubPositions[1]   

octet 16: positions[4]    
octet 20: positions[5]   

For the WebGLBuffer object bound to the passed target write the passed data starting at the passed offset

>>https://registry.khronos.org/webgl/specs/latest/1.0/
>>5.14.5 Buffer objects
>>
>>For the WebGLBuffer object bound to the passed target write the passed data starting 
>> at the passed offset
</p>
<pre><code>

gl.enableVertexAttribArray(positionAttributeLocation);



gl.vertexAttribPointer(
	positionAttributeLocation,
	2, // size
	// number of components per vertex attribute
    // ici c'est 2, parce que dans notre vertex on a : attribute vec2 a_position

	gl.FLOAT, //type,
	false, // normalize,
	0, //stride,
	0, // offset
);

gl.drawArrays(gl.POINTS, 0, 3);



  	</code></pre>


  	<canvas></canvas>
  	<script>
  		const canvas = document.querySelector('canvas');
  		canvas.style.width="500px";
  		canvas.style.height="200px";
  		canvas.width=5;
  		canvas.height=2;

  		const gl = canvas.getContext('webgl');

  		const vertex = `
  		attribute vec2 a_position;
		void main() {
  		  gl_Position = vec4(a_position, 0, 1);
  		  gl_PointSize = 1.0;
  	    }`;

  	    const fragment = `
        precision mediump float;
        void main() {
          gl_FragColor = vec4(1, 0, 0, 1);
        }`;

        let prg = gl.createProgram();
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, vertex);
        gl.shaderSource(fragmentShader, fragment);
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);
        gl.attachShader(prg, vertexShader);
        gl.attachShader(prg, fragmentShader);
        gl.linkProgram(prg);

        gl.useProgram(prg);

        const positionAttributeLocation = gl.getAttribLocation(prg, 'a_position');

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        const positions = new Float32Array(6);

        positions[0]=-1+7/5;
		positions[1]=-1+1/2;
		/*
		-----
		---X-
		*/

		positions[2]=-1+1/5;
		positions[3]=-1+3/2;
		/*
		X----
		-----
		*/

		positions[4]=-1+9/5;
		positions[5]=-1+3/2;
		/*
		----X
		-----
		*/

	gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);



/*
float32Array(6)
bufferData(...positions.byteLength)
 x      y       x    y    x    y    
bbbb   bbbb    bbbb bbbb bbbb bbbb 
32bits 32bits   ...  ...  ...  ...


gl.bufferSubData(gl.ARRAY_BUFFER, 8, positions.slice(0,4));

               |-----------------|
0123   4567    8
 x      y       x    y    x    y    
bbbb   bbbb    bbbb bbbb bbbb bbbb 
32bits 32bits   ...  ...  ...  ...


bufferData : 

positions[0]    -----
positions[1]    ---1-

positions[2]    2----
positions[3]    ---1-

positions[4]    2---3
positions[5]    ---1-


*/
        const subPositions = new Float32Array(2);
        subPositions[0]= -1 + 3/5;
        subPositions[1]= -1 + 1/2;
        // subPositions est un Float32array de 2 éléments
        // chaque élément occupe 4 octets 
        // donc subPositions occupe 8 octets

	gl.bufferSubData(gl.ARRAY_BUFFER, 8, subPositions);

/*
bufferSubData : contient un seul point, on le note A

effet sur le bufferData courant :

positions[0]    -----   bbbb   4 octets 4*8=32bits
positions[0]    ---1-   bbbb   4 octest 

positions[0]    -----   bufferSubData(gl.ARRAY_BUFFER, 8 , subPositions)
positions[0]    -A-1-

positions[0]    ----3
positions[0]    -A-1-

bufferSubData modifie une partie du buffer courant
*/



      	gl.enableVertexAttribArray(positionAttributeLocation);
 
      	gl.vertexAttribPointer(
      		positionAttributeLocation,
      		2,
      		gl.FLOAT,
      		false,
      		0,
      		0,
      	);

      	gl.drawArrays(gl.POINTS, 0, 3);

  </script>
  <script src="highlight/highlight.min.js"></script>
  <script>
  	hljs.highlightAll();
  </script>

</body>
</html>
