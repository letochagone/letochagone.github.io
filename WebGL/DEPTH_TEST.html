<!DOCTYPE html>
<html lang="fr">
<meta charset="UTF-8">
<title>DEPTH_TEST</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="">
<style>
html,body {font-family:"Verdana",sans-serif}
h1,h2,h3,h4,h5,h6 {font-family:"Segoe UI",sans-serif}

html, body {
  height: 100%;
}
canvas {
  width: 100%;
  height: 100%;
  display: block;   /* this is IMPORTANT! */
}

    pre {
      background-color: black;
      color: white;
    }
    .string {
      color:#A1E46D;
    }
    .special {
      color:#D6665D;
    }
    .egale {
      color:#FF00FF;
    }

        .htmlWord {
        color:yellow;
    }
    .glWord {
      color:aqua;
    }


    .explication {
  white-space: pre;
}



td {
    border: 1px solid ;
    padding: 0.25em ;
}





table {
  border-collapse: collapse;
  width: 100%;
}

caption {
    background-color: lightgray;
}
</style>
<body>
    <p>
        le but de cette page est d'illustrer l'application d'une compréhension de WebGL.
        Merci à Greggman.

        https://stackoverflow.com/questions/27148273/what-is-the-logic-of-binding-buffers-in-webgl/27164577#27164577

    </p>
    <canvas  id="canvas"></canvas>


<pre><code class="lecode">

        let canvas = document.getElementById('canvas');
        let gl = canvas.getContext('webgl');


        let verticesTriangle1=[
            -1,-1,0,
            0,1,0,
            1,-1,0
            ];

/*
 Buffer objects (sometimes referred to as VBOs) hold vertex attribute data for the GLSL shaders. 
*/
        let vertex_buffer1 = gl.createBuffer();
        /*
        https://registry.khronos.org/webgl/specs/latest/1.0/#5.14.5
             Create a WebGLBuffer object and initialize it with a buffer object name as if by calling glGenBuffers.


          un buffer va contenir les données pour les variables de type attribute dans le code glsl.

        */

            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer1);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesTriangle1), gl.STATIC_DRAW);



        let verticesTriangle2=[
            -1,1,0,
            1,1,0,
            0,-1,0
      
            ];

            let vertex_buffer2 = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer2);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesTriangle2), gl.STATIC_DRAW);



            let vertCode = `
            attribute vec3 coordinates;
            void main() {
                gl_Position = vec4(coordinates, 1.0);
            }`;
            
            let fragCode = `
            precision mediump float;
            uniform vec4 uColor;

            void main() { 
                gl_FragColor = uColor;
            }`;


            let vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, vertCode);
            gl.compileShader(vertShader);
            let fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragCode);
            gl.compileShader(fragShader);
            let shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertShader);
            gl.attachShader(shaderProgram, fragShader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);


            let coord = gl.getAttribLocation(shaderProgram, "coordinates");
            gl.enableVertexAttribArray(coord);

            let colorLoc  = gl.getUniformLocation(shaderProgram,"uColor");


            gl.enable(gl.DEPTH_TEST);
            gl.viewport(0, 0, canvas.width, canvas.height);


            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer2);
            gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
            gl.uniform4f(colorLoc,0,1,0,1);


            gl.drawArrays(gl.TRIANGLES, 0, 3);
        
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer1);
            gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
            gl.uniform4f(colorLoc,0,0,1,1);


            gl.drawArrays(gl.TRIANGLES, 0, 3);




</code></pre>

<pre><code class="lecode">
            let coord = gl.getAttribLocation(shaderProgram, "coordinates");
            gl.enableVertexAttribArray(coord);

</code></pre>

<p>
    After a program object has been linked successfully, the bindings of attribute
variable names to indices can be queried. The command
int GetAttribLocation( uint program, const char *name );
returns the generic attribute index that the attribute variable named name was bound
to when the program object named program was last linked. name must be a null-
terminated string. If name is active and is an attribute matrix, GetAttribLocation
returns the index of the first column of that matrix. If program has not been suc-
cessfully linked, the error INVALID_OPERATION is generated. If name is not an
active attribute, or if an error occurs, -1 will be returned.
The binding of an attribute variable to a generic attribute index can also be
specified explicitly. The command
void BindAttribLocation( uint program, uint index, const
char *name );
    </p>
<p class="explication">
    pseudo code

    global state :
    -------------
    ARRAY_BUFFER_BINDING : null

    vertex array:
    -------------
    [
      {enabled: false,...},
      ...
      {enabled: true,...},
      ...
      }
    ]

le tableau "Vertex Array"  contient les états des variables de type "attribute".
 Ce type définit comment envoyer les données d'un buffer vers le vertex shader.
Dans le tableau "vertex array", les éléments sont sous la forme :

vertex array:
=============
 [
  {...},{...},
  { enabled: false, type: gl.FLOAT, size: 3, normalized: false, stride: 0, offset: 0, buffer: null },
  {...}
]

la ligne : 
  let coord = gl.getAttribLocation(shaderProgram, "coordinates");
assigne l'indice de 'coordinates' :
  attribute vec3 coordinates;

dans ce tableau.

la ligne 
  gl.enableVertexAttribArray(coord);
  //Enable the vertex attribute at index 'coord' as an array.

donne à l'élément "enabled" la valeur true :


vertex array:
=============
 [
 indice 0  {...},
 indice 1  {...},
  ...,
  indice 'coord' { enabled: TRUE, type: gl.FLOAT, size: 3, normalized: false, stride: 0, offset: 0, buffer: null },
  ...
]


         </p>





<pre><code class="lecode">
  let vertex_buffer1 = gl.createBuffer();

</code></pre>
<p class="explication">
  crée un buffer vertex_buffer1
</p>


<pre><code class="lecode">
  gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer1);

</code></pre>
<p class="explication">
    le buffer vertex_buffer1 devient le buffer courant.
    The `ARRAY_BUFFER` binding point is mostly
just like an internal variable inside webgl. You set it by calling
`gl.bindBuffer(gl.ARRAY_BUFFER, someBuffer);` and then all other
buffer functions can refer to the buffer bound there."
    

    global state :
    =============
      ARRAY_BUFFER_BINDING : vertex_buffer1

    </p>

<div class="globalstate">
<table >
    <caption>GLOBAL STATE</caption>
    <tbody>
        <tr>
            <td>ARRAY_BUFFER_BINDING</td>
            <td>vertex_buffer1</td>
        </tr>
  
 
    </tbody>

</table>
</div>







<pre><code class="lecode">
  gl.bufferData(gl.ARRAY_BUFFER, 
    new Float32Array([
      -1, -1, 0,
       0,  1, 0,
       1, -1, 0
    ]),
  gl.STATIC_DRAW);

</code></pre>

<p class="explication">
global state :
=============
  ARRAY_BUFFER_BINDING : vertex_buffer1 = [-1, -1, 0,0,  1, 0,1, -1, 0]

On rempli le buffer courant.
Le buffer courant, c'est à dire le buffer précédemment définit comme buffer courant 
par la fonction bindbuffer.

On comprend ainsi que la fonction bufferData n'a pas de paramètre de type buffer.

    </p>

<pre><code class="lecode">

    gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);<br>

</code></pre>


<table>
  <tr>
    <th>enabled</th>
    <th>size</th>
    <th>type</th>
    <th>normalize</th>
    <th>stride</th>
    <th>offset</th>
    <th>divisor</th>
    <th>buffer</th>
  </tr>
  <tr>
    <td>Peter</td>
    <td>Griffin</td>
    <td>$100</td>
  </tr>
  <tr>
    <td>Lois</td>
    <td>Griffin</td>
    <td>$150</td>
  </tr>
  <tr>
    <td>Joe</td>
    <td>Swanson</td>
    <td>$300</td>
  </tr>
  <tr>
    <td>Cleveland</td>
    <td>Brown</td>
    <td>$250</td>
  </tr>
</table>

    <p class="explication">

    global state :
    ==============
    ARRAY_BUFFER_BINDING : vertex_buffer1=  [-1, -1, 0,0,  1, 0,1, -1, 0]

    vertex array:
    ============
    [ {enabled: false,
      {enabled: true,...}
    }
    ]
    
    </p>


    this.vertexAttribPointer = function(location, size, type, normalized, stride, offset) {
  const attribute = vertexArray.attributes[location];
  attribute.size       = size;       // num values to pull from buffer per vertex shader iteration
  attribute.type       = type;       // type of values to pull from buffer
  attribute.normalized = normalized; // whether or not to normalize
  attribute.stride     = stride;     // number of bytes to advance for each iteration of the vertex shader. 0 = compute from type, size
  attribute.offset     = offset;     // where to start in buffer.

  // IMPORTANT!!! Associates whatever buffer is currently *bound* to 
  // "arrayBuffer" to this attribute
  attribute.buffer     = arrayBuffer;
};






</body>









    <script>
        


        let canvas = document.getElementById('canvas');
        let gl = canvas.getContext('webgl');


           let fragCode = `
            precision mediump float;
            uniform vec4 uColor;

            void main() { 
                gl_FragColor = uColor;
            }`;

            let vertCode = `
            attribute vec3 coordinates;
            void main() {
                gl_Position = vec4(coordinates, 1.0);
            }`;
    
            let vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, vertCode);
            gl.compileShader(vertShader);
            let fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragCode);
            gl.compileShader(fragShader);
            let shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertShader);
            gl.attachShader(shaderProgram, fragShader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);

 let coord = gl.getAttribLocation(shaderProgram, "coordinates");
            gl.enableVertexAttribArray(coord);


        let verticesTriangle1=[
            -1,-1,0,
            0,1,0,
            1,-1,0
            ];

/*
 Buffer objects (sometimes referred to as VBOs) hold vertex attribute data for the GLSL shaders. 
*/
        let vertex_buffer1 = gl.createBuffer();
        /*
        https://registry.khronos.org/webgl/specs/latest/1.0/#5.14.5
             Create a WebGLBuffer object and initialize it with a buffer object name as if by calling glGenBuffers.


          un buffer va contenir les données pour les variables de type attribute dans le code glsl.

        */

            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer1);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesTriangle1), gl.STATIC_DRAW);



        let verticesTriangle2=[
            -1,1,0,
            1,1,0,
            0,-1,0
      
            ];

            let vertex_buffer2 = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer2);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesTriangle2), gl.STATIC_DRAW);



        
 


           
            let colorLoc  = gl.getUniformLocation(shaderProgram,"uColor");


            gl.enable(gl.DEPTH_TEST);
            gl.viewport(0, 0, canvas.width, canvas.height);


            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer2);
            gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
            gl.uniform4f(colorLoc,0,1,0,1);


            gl.drawArrays(gl.TRIANGLES, 0, 3);
        
                                gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer1);
                                            gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
                                                        gl.uniform4f(colorLoc,0,0,1,1);



            gl.drawArrays(gl.TRIANGLES, 0, 3);






























syntaxHighlightAll("lecode");



function syntaxHighlightAll(elementsClass) {
    let lesElements = document.getElementsByClassName(elementsClass);
    syntaxHighlight(lesElements.item(0));
    for (let i = 0; i < lesElements.length; i++) {
      syntaxHighlight(lesElements.item(i));
    }
}





function syntaxHighlight(elementId) {

  //let strMessage1 = document.getElementById(elementId) ;
let strMessage1=elementId;

  let strReg1 = /"(.*?)"/g;
  let strReg2 = /'(.*?)'/g; // '(fgerrge r re r)'  , . = a caracter  , .* , une suite de caracter , .*? la suite de caracter la plus petite
  
  let strReg3 = /`([\w|\W|\s]*?)`/g ;
  // \w matches any word caracter : a..z ou A...Z ou _
  // \W matches any no word caracater : sauf de ligne, tabulation, espace,
  /*
  le ? dans  va éviter de récupérer la chaine "A...F"  "ArjgrejgegjeB"CgjgrD"EgrgrF"
  mais va récupérer "A..B" et "E..F"


  /<(\w+?)>/g   va récupérer fjeejfe dans <fjeejfe>
  /<\\(\w+?)>/g va récupérer fjeejfe dans <\fjeejfe>


  */

let maReg = /(<\\(\w+?)>|<(\w+?)>)/g ;
maReg = /(&lt;\\(\w+?)&gt;|&lt;(\w+?)&gt;)/g ;

let maReg2 = /(gl[\.|\s])/g ;




  let specialReg = /\b(new|let|var|if|do|function|while|switch|for|foreach|in|continue|break)(?=[^\w])/g ;

  let specialJsGlobReg = /\b(document|window|Array|String|Object|Number|\$)(?=[^\w])/g ;
  let specialJsReg = /\b(getElementsBy(TagName|ClassName|Name)|getElementById|typeof|instanceof)(?=[^\w])/g ;
  let specialMethReg = /\b(indexOf|match|replace|toString|length)(?=[^\w])/g ;
  let specialCommentReg  = /(\/\*.*\*\/)/g ;
  let inlineCommentReg = /(\/\/.*)/g;
  let htmlTagReg = /(&lt;[^\&]*&gt;)/g;

  let string = strMessage1.innerHTML;


  
  let parsed = string.replace(strReg1,'<span class="string">"$1"</span>');



  parsed = parsed.replace(maReg,'<span class="htmlWord">$1</span>');
  parsed = parsed.replace(maReg2,'<span class="glWord">$1</span>');



  //parsed = parsed.replace(maReg,'<span class="htmlWord">$1</span>');
  //parsed = parsed.replace(maReg2,'<span class="glWord">$1</span>');



  parsed = parsed.replace(strReg2,"<span class=\"string\">'$1'</span>");
  parsed = parsed.replace(strReg3,"<span class=\"string\">`$1`</span>");
  parsed = parsed.replace(specialReg,'<span class="special">$1</span>');
  parsed = parsed.replace(specialJsGlobReg,'<span class="special-js-glob">$1</span>');
  parsed = parsed.replace(specialJsReg,'<span class="special-js">$1</span>');
  parsed = parsed.replace(specialMethReg,'<span class="special-js-meth">$1</span>');
  //parsed = parsed.replace(htmlTagReg,'<span class="special-html">$1</span>');
  parsed = parsed.replace(specialCommentReg,'<span class="special-comment">$1</span>');
  parsed = parsed.replace(inlineCommentReg,'<span class="special-comment">$1</span>');

  strMessage1.innerHTML  = parsed;

}




    </script>
</body>

</html>
