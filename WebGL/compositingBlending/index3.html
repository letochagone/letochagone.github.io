<!doctype html>
<html>
  <head>
	  <!--
	  div  style: background-color
	       img style: mix-blend-mode  src=...
	  -->
    <style>
      #canvasConcret , #canvasConcret2  , #canvasConcret3{
        display: block;
        background-color: rgba(155, 155, 155, 0.2);
        width:150px;
        height:150px;
        image-rendering: pixelated;
      }
      
     
      .canvas { 
        background-color: rgba(155, 155, 155, 0.2);
        width: 150px;
        height: 150px;
      }
      .clearcolor {
	    background-color: rgba(51, 102, 127,0.8);
	    width: 100px;
	    height: 100px;
      }
      .fragcolor {
		 width: 50px;
		 height: 50px;
		 background-color: rgba(204, 51, 178, 0.5); 
	  }
<!--
fragcolor  0.80  0.20  0.69 0.50
clearcolor 0.20  0.40  0.49 0.80
canvas     0.61  0.61  0.61 0.20

-->
      
    </style>
    
  </head>
  <body>
	  
	  <p>3 éléments superposés avec des couleurs</p>
  
   	<div class="canvas">
  	  <div class="clearcolor">
		  <div class="fragcolor"></div>
  	  </div>
  	</div>

	  <p>2 éléments superposés avec des couleurs</p>
  
   	<div class="canvas">
		  <div class="fragcolor"></div>
  	</div>

  <p>clearcolor et fragcolor, mais le blending n'est pas activé</p>
    <canvas id="canvasConcret"></canvas>
    <p>on enlève le clearColor. ça ne change pas la couleur du point. Sans blending, cette couleur est composée avec celle du canvas</p>
    <canvas id="canvasConcret2"></canvas>
    
    <p>blablable</p>
    <canvas id="canvasConcret3"></canvas>
   
    <script>
   
   
   
  /*
  add two array a et b
  a.map( ( i ,j ) =>i+b[j])
  */
//let fragcolorRGB = [0.80,  0.20,  0.69];
let fragcolorRGB = [204/255,  51/255,  178/255];
let fragcolorA = 0.50;

//let clearcolorRGB =[0.20,  0.40 , 0.49];
let clearcolorRGB =[51/255, 102/255, 127/255];
let clearcolorA= 0.80;

//let canvasRGB  =  [ 0.61,  0.61 , 0.61];
let canvasRGB  =  [ 155/255, 155/255, 155/255];
let canvasA=  0.20;

let bodyRGB= [ 1,1,1];
let bodyA = 1;

function compositing(Cs,as1,Cb,ab,as2) {
	let co=[];
	for (let i=0; i<3; i++) {
		co[i]= Cs[i]*as1+Cb[i]*ab*(1-as2);
	}
	let ao= as2 + ab * (1-as2);
	return {co:co, ao:ao};
}

let un=compositing(fragcolorRGB,fragcolorA,clearcolorRGB,clearcolorA,fragcolorA);
let deux=compositing(un.co, 1.0, canvasRGB,canvasA,un.ao);
let trois = compositing(deux.co, 1.0, bodyRGB,bodyA,deux.ao);
console.log(trois);

let aaa=compositing(fragcolorRGB,fragcolorA,canvasRGB,canvasA,fragcolorA);
let bbb=compositing(aaa.co,1.0,  bodyRGB,bodyA,aaa.ao);
console.log(bbb);
{
	//fragcolor sur clearcolor
	
 let Cs = fragcolorRGB;
 let as = fragcolorA;
 let Cb= clearcolorRGB;
 let ab = clearcolorA;
 
 let Csas = Cs.map(x=>x * as);
 let Cbab = Cb.map(x=>x * ab);
 let Cbab1_As = Cbab.map(x=> x * ( 1-as ));
 
 let co = Csas.map( (i,j)=>i+Cbab1_As[j]);
 let ao = as + ab * ( 1- as);
  
  //co ao sur canvas
  
  Cs = co;
  as = ao;
  Cb= canvasRGB;
  ab = canvasA;
  Csas = Cs;
  Cbab = Cb.map(x=>x * ab);
  Cbab1_As = Cbab.map(x=> x * ( 1-as ));
  co = Csas.map( (i,j)=>i+Cbab1_As[j]);
  ao = as + ab * ( 1- as);
   

}
//co ao sur canvas
 




const canvasVirtuelPourWebGL = document.createElement("canvas");
//const canvasVirtuelPourWebGL = document.getElementById("canvasConcret");
const gl = canvasVirtuelPourWebGL.getContext("webgl", {premultipliedAlpha: false});
//const gl = document.querySelector("canvas").getContext("webgl", {premultipliedAlpha: false});
gl.canvas.width=3;
gl.canvas.height=3;
/*
-1+1/3  -1+5/3   -1+7/3

*/
const VERTEX_SHADER = `
  attribute vec4 aColor;
  varying vec4 vColor;
  
  void main() {
    vColor = aColor;
    gl_Position= vec4(-1.0+1.0/3.0, -1.0+1.0/3.0,0.0,1.0);
    gl_PointSize=1.0;
    
  }
`;
const FRAGMENT_SHADER = `
  precision mediump float;
  varying vec4 vColor;
  
  void main() {  
    gl_FragColor = vColor;  
    
  }
`;
const vshader = gl.createShader(gl.VERTEX_SHADER);
const fshader = gl.createShader(gl.FRAGMENT_SHADER);
const program = gl.createProgram();
gl.shaderSource(vshader, VERTEX_SHADER);
gl.shaderSource(fshader, FRAGMENT_SHADER);
gl.compileShader(vshader);
gl.compileShader(fshader);
gl.attachShader(program, vshader);
gl.attachShader(program, fshader);
gl.linkProgram(program);
gl.useProgram(program);

gl.viewport(0,0,3,3);

gl.clearColor(0.2,0.4,0.5,0.8);
gl.clearColor(51/255,102/255,127/255,0.8);
//#clearcolor	    background-color: rgba(51, 102, 127,0.8);
gl.clear(gl.COLOR_BUFFER_BIT);


let colors=[
  204/255,	51/255,	178/255,	0.5,
  0.6,	0.4,	0.8,	0.6,
  1,	1,		1,		1
];
let aColor = gl.getAttribLocation(program,"aColor");
let colorBuffer= gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,colorBuffer);
gl.bufferData(gl.ARRAY_BUFFER,
  new Float32Array(colors),gl.STATIC_DRAW);
gl.enableVertexAttribArray(aColor);
gl.vertexAttribPointer(aColor,4,gl.FLOAT,false,0,0);

gl.bindFramebuffer(gl.FRAMEBUFFER,null);

if (false) {
	let fb= gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER,fb);
	let tex=gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D,tex);
	let targetTextureWidth = 2;
	let targetTextureHeight = 2;
	const level = 0;
	const internalFormat = gl.RGBA;
	const border = 0;
	const format = gl.RGBA;
	const type = gl.UNSIGNED_BYTE;
	const data = null;
	gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                targetTextureWidth, targetTextureHeight, border,
                format, type, data);
    // set the filtering so we don't need mips
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,tex,0);


}

/*
blendFuncSeparate(srcRGB, dstRGB , srcAlpha , dstAlpha)
RGB=  sourceColor * srcRGB + destinationColor * dstRGB
A  =  sourceAlpha * srcAlpha + destinationAlpha* dstAlpha
*/


//gl.enable(gl.BLEND);
///gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);
/*
11fev
=====
clearcolor = gl.clearColor(0.2,0.4,0.5,1.0);
Cb = [0.2, 0.4, 0.5][i]; ab=1.0;  Cs=[0.6, 0.4 , 0.8][i]; as=0.6;co=Cs*as+Cb*ab*(1-as);
source 
g_fragcolor = 0.6, 0.4 , 0.8, 0.6,
destination
clearColor = (0.2,0.4,0.5,1.0);
RGB = [0.6, 0.4 , 0.8][i] * 0.6  + [0.2,0.4,0.5][i] * (1-0.6);
A = 0.6 + 1.0 * (1-0.6) = 1



1er point
========
la source : couleur du point
g_fragcolor = 0.6, 0.4 , 0.8, 0.6,
la destination : couleur du clearcolor
gl.clearColor = 0.2,  0.4,  0.5  0.2
** gl.clearColor = 0.0 0.0 0.0 0.0
gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);
RGB = sourceColor * SRC_ALPHA  + destinationColor * ONE_MINUS_SRC_ALPHA
RGB = [0.6 ,  0.4 ,  0.8][i] * 0.6  + [ 0.2 ,  0.4 , 0.5][i]*(1-0.6);
RGB = [ 0.44 , 0.4 ,0.68]
** RGB = [0.6 ,  0.4 ,  0.8][i] * 0.6  
** RGB= [ 0.36 , 0.24  0.48]
A   = sourceAlpha * ONE + destinatinAlpha * ONE_MINUS_SRC_ALPHA
A   = 0.6 + 0.2 * (1-0.6)
A   = 0.68
** A = 0.6
résultant blending du 1er point :
RGB=[0.44, 0.4 , 0.68]
A=0.68
** résultant blending sans clearcolor
** RGB = [ 0.36 , 0.24  0.48]  A=0.6

compositing avec le fond

 Cb = [0.67, 0.67, 1][i];
 ab= 1;
 Cs = [0.44, 0.4 , 0.68][i];
 as= 0.68;
 ** Cs= [ 0.36 , 0.24 , 0.48][i]; as =0.6; Cb = [0.67, 0.67, 1][i]; co = Cs*as+Cb*(1-as)
 co = Cs*as+Cb*ab*(1-as);
 co = [ 0.51 0.48 0.78 ]
 PAREIL QUE COPIE ECRAN
 
 fragcolor =======
 clearcolor ======
 couleur canvas
 
2e point
=======
la source  : couleur 2e point
0.3, 0.7 , 0.5, 0.5,
la destination : résultat blending 1er point
0.32  0.08  0.16  0.2
gl.blendFuncSeparate(gl.DST_ALPHA,gl.ONE,gl.ZERO,gl.ONE);
========================================================
  RGB = sourceColor * DST_ALPHA + destinationColor * ONE
  RGB = [0.3, 0.7 , 0.5][i]*  0.2 + [0.32  0.08  0.16 ][i]
  RGB = 0.38  0.22 0.26
    A = 0.2

compositing avec le fond 
 Cb = [0.67, 0.67, 1]
 ab= 1
 Cs = [0.38,0.22,0.26][i]
 as= 0.2
 
 co = Cs as + Cb ab (1-as)
 co = [0.38,0.22,0.26][i] * 0.2 + [0.67, 0.67, 1][i]*0.8
 co=  0.612  0.58  0.852
 PAREIL QUE CAPTURE ECRAN
  
  

*/


/*
gl.drawArrays(gl.POINTS, 0, 1);

{
let canvasReelPour2D= document.getElementById("canvasConcret");
canvasReelPour2D.width=2;
canvasReelPour2D.height=2;
let canvasReelPour2DCtx=canvasReelPour2D.getContext("2d");
//canvasReelPour2DCtx.canvas.width=2;
//canvasReelPour2DCtx.canvas.height=2;
canvasReelPour2DCtx.drawImage(canvasVirtuelPourWebGL,0,0);
}

canvas        background-color: rgba(155, 155, 155, 0.2);
                                      0.61 0.61 0.61 0.2
clearColor=  (0.2,0.4,0.5,0.8);

fragcolors=[
  0.8,	0.2,	0.7,	0.5,
  0.6,	0.4,	0.8,	0.6,

sans blendfunc
=============
valeur  hors du point
0.34 0.51 0.58
calcul:

clearColor=  (0.2,0.4,0.5,0.8);
canvas = 0.61 0.61 0.61 0.2
co = Cs*as+Cb*ab*(1-as)
co = [0.2,0.4,0.5][i]*0.8+[0.61,0.61,0.61][i]*0.2*(1-0.8);
co = 0.18 0.34 0.42
ao=as+ab*(1-as)
ao= 0.84
on compose avec le fond
[0.18 ,0.34 ,0.42][i]+1-0.84
=0.34 0.50 0.58
PAREIL QUE CAPTURE ECRAN

on reprend le calcul , mais dans l'autre sens 
calcul couleur clearcolor sur canvas composé
canvas composé :
source  = 0.61 0.61 0.61 0.2
destination= 1 1 1 1 
co = [0.61 , 0.61 , 0.61 ][i]*0.2+1-0.2
co = 0.92 0.92 0.92 
maintenant le dernier résultat est la destination
la source est le clearcolor
[0.2,0.4,0.5][i]*0.8+0.92*0.2
0.34 0.50 0.58

cool pareil !!!!

valeur sur le point
0.86 0.56 0.81
calcul
il n'y a pas de blending, testons le compositing
source
le fragcolor:
Cs  0.8,	0.2,	0.7  	as 0.5,
destination
le canvas
Cb  0.61 0.61 0.61   ab 0.2
co=[0.8,0.2,0.7][i]*0.5+[0.61,0.61,0.61][i]*0.2*(1-0.5)
co= 0.461  0.161 0.411
ao = as + ab * (1-as)
ao = 0.5 + 0.2 * 0.5
ao = 0.6
on compose avec le fond blanc
co = [0.461 , 0.161 , 0.411][i]+1-0.6
co = 0.86 0.56 0.81
pareil que capture ecran !!!

*/
gl.drawArrays(gl.POINTS, 0, 1);

{
let canvasReelPour2D= document.getElementById("canvasConcret");
canvasReelPour2D.width=3;
canvasReelPour2D.height=3;
let canvasReelPour2DCtx=canvasReelPour2D.getContext("2d");
//canvasReelPour2DCtx.canvas.width=2;
//canvasReelPour2DCtx.canvas.height=2;
canvasReelPour2DCtx.drawImage(canvasVirtuelPourWebGL,0,0);
}


gl.clearColor(0,0,0,0);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.drawArrays(gl.POINTS, 0, 1);

{
let canvasReelPour2D= document.getElementById("canvasConcret2");
canvasReelPour2D.width=3;
canvasReelPour2D.height=3;
let canvasReelPour2DCtx=canvasReelPour2D.getContext("2d");
//canvasReelPour2DCtx.canvas.width=2;
//canvasReelPour2DCtx.canvas.height=2;
canvasReelPour2DCtx.drawImage(canvasVirtuelPourWebGL,0,0);
}

gl.clearColor(51/255,102/255,127/255,0.8);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.drawArrays(gl.POINTS, 0, 1);
{
let canvasReelPour2D= document.getElementById("canvasConcret3");
canvasReelPour2D.width=3;
canvasReelPour2D.height=3;
let canvasReelPour2DCtx=canvasReelPour2D.getContext("2d");
//canvasReelPour2DCtx.canvas.width=2;
//canvasReelPour2DCtx.canvas.height=2;
canvasReelPour2DCtx.drawImage(canvasVirtuelPourWebGL,0,0);
}

let pixels = new Uint8Array(3*3*4);
gl.readPixels(0,0,3,3,gl.RGBA,gl.UNSIGNED_BYTE,pixels);
console.log(pixels);
    </script>
  </body>

</html>
